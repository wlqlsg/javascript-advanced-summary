JavaScript 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言
 编译型语言写的程序执行之前，需要一个专门的编译过程，把所有程序编译成为机器语言的文件
 解释型语言在运行程序的时候才编译，每执行一段代码就要翻译一段代码
 两种方式只是编译的时机不同
JavaScript 代码的执行过程
 JavaScript 引擎是一段一段地运行代码的
 JavaScript 代码执行时，会为当前代码创建相应的运行环境
JavaScript 运行环境
 全局环境：代码运行起来后会进入全局环境
 函数环境：当函数被调用执行时，会进入当前函数中执行代码
 eval 环境：不建议使用，不做介绍
执行上下文
 可以理解为当前代码的运行环境
 作用是用来保存当前代码运行时所需要的数据
 在全局环境、函数环境中会创建执行上下文
执行上下文栈
 执行上下文栈按照函数的调用顺序来管理执行上下文
 栈底永远是全局上下文，栈顶是当前正在执行的函数
 特点：先进后出
当一个函数调用时，一个新的执行上下文就会被创建。
执行上下文的生命周期
 创建阶段
 执行阶段
 等待回收阶段
每个执行上下文都有一个与之关联的变量对象（variable object）和一个作用域链（scope chain）
变量对象（Variable Object）
 变量对象是与执行上下文相关的数据作用域(scope of data) 。
 变量对象是与上下文关联的特殊对象，用于存储被定义在上下文中的变量(variables) 和函数声明(function declarations) 
变量对象创建过程
 建立 arguments 对象
 检查当前上下文的函数声明
 检查当前上下文中的变量声明
JavaScript 代码的执行分为两个阶段
 代码编译阶段：将代码翻译成可执行代码
 代码执行阶段：执行可执行代码
JavaScript 编译和执行过程
 全局编译阶段（预解析）
 全局顺序执行阶段（变量赋值、函数调用等操作）
 当遇到函数调用时，在执行函数内代码前，进行函数范围内的编译
 当存在函数嵌套时，以此类推，会进行多次函数预解析
预解析工作之一 —— 声明提升
 所有的变量声明和函数声明提升到当前作用域的最前面
声明提升规则
 规则1：函数声明整体提前
 规则2：变量声明提前，赋值留在原地
 规则3：函数会首先被提升，然后才是变量
 规则4：函数声明有冲突，会覆盖；变量声明有冲突，会忽略
浏览器中的全局上下文的变量对象
 变量对象就是 window 对象
 在页面关闭前一直存在
作用域
 作用域是一套关于如何存储变量当中的值，并且能在之后对这个值进行访问和修改的规则
 作用域的作用
 作用域指定变量与函数的可访问范围
 作用域控制着变量与函数的可见性
全局作用域（global scope）
 在全局作用域下声明的变量叫做全局变量
 全局变量在全局（代码的任何位置）下都可以使用
 全局作用域中无法访问到局部作用域中的变量
全局变量的创建方式
 在全局作用域下 var 声明的变量
 在函数内部，没有使用 var关键字声明直接赋值的变量
 使用 window 全局对象创建的属性和方法
函数作用域（function scope）
 在函数作用域下声明的变量叫做局部变量
 局部变量只在当前函数内部中使用
 局部作用域中可以访问到全局作用域中的变量
局部变量的创建方式
 在函数内部通过 var 声明的变量
 函数的形参
块作用域（block scope）
 任何一对花括号 { } 中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域
 ES5 没有块作用域，在 ES6 中添加了块作用域
作用域共有两种主要的工作模型
 词法作用域（静态性）
是由函数定义的书写位置决定的，与调用位置无关
 动态作用域（动态性）
由调用位置决定，不关心变量和函数的定义的书写位置
词法作用域补充部分
– 通过 new Function 创建的函数对象不遵从静态词法作用域
– 通过 new Function 创建的函数对象总是在全局作用域中执行
[[scope]] 属性
 虚拟属性，无法访问和修改
 函数创建（定义）时生成的属性，保存着这个函数所有父级执行上下文环境中的变量对象的集合 
作用域链（Scope Chain）
 由当前执行环境与所有父级执行环境的一系列变量对象组成
 提供对变量和函数访问的权限和顺序的规则
函数定义
 [[scope]]  作用域确定
 函数执行
 编译阶段：作用域链确定  创建变量对象（声明提升规则）
    （执行上下文创建阶段）
 执行阶段：修改变量对象
  （执行上下文执行阶段）
 函数执行结束
 执行环境不被引用，执行上下文被销毁
 执行环境被引用，执行上下文不销毁


