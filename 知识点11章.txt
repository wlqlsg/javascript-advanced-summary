定义在构造函数内部的方法，会在它的每一个实例上都克隆这个方法（会重新分配内存）。
 定义在构造函数的 prototype 属性上的方法会让它的所有实例对象都共享这个方法，但是不会在每个实例的内部重新定义这个方法（不会重新分配内存）。
 如果我们的应用需要创建很多新的对象，并且这些对象还有许多的方法，为了节省内存，我们建议把这些方法都定义在构造函数的 prototype 属性上。
 在某些情况下，我们需要将某些方法定义在构造函数中，这种情况一般是因为我们需要访问构造函数内部的私有变量。 
 函数内方法：定义在构造函数内部的方法，会在它的每一个实例对象上都克隆这个方法，内存占用比较大，但可以访问函数内部的私有变量。
 prototype 上的方法：定义在构造函数的 prototype 属性上的方法会让它的所有实例对象都共享这个方法，但是不会在每个实例对象的内部重新定义这个方法，内存占用比较小，但不可以访问函数内部的私有变量。
拷贝
 浅拷贝
拷贝基本类型的值
拷贝引用类型的引用（地址）
对象拷贝时，如果属性值是引用数据类型时，这时候我们传递的只是一个地址。因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即父子对象发生了关联，两者的属性值会指向同一内存空间。
深拷贝 = 浅拷贝 + 递归
深拷贝
拷贝基本类型的值
拷贝引用类型时（比如数组和或对象），使用递归，把父对象中所有属于引用类型的对象都遍历赋给子对象即可。
1. 创建一个新的对象给 person2
2. 判断 person1 的属性值的数据类型
3. 如果是基本数据类型，直接赋值，即
person2[key]=person1[key]
4. 如果是引用对象，为person2[key]创建新的对象，person2[key] = {}||[]
5. 然后遍历person1[key]的属性值拷贝给person2[key]
6........
浅拷贝： 将原对象或原数组的引用直接赋给新对象的属性，新对象／数组的属性只是原对象属性的一个引用
 深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”拷贝过来，是“值”而不是“引用”
 深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。
 深拷贝的缺点
 虽然深拷贝能够避免浅拷贝出现的问题，但是却会带来性能上的问题，如果一个对象非常复杂或数据庞大，性能消耗也会增加
继承
 继承属性和方法
 继承，本质上讲是一种代码重用机制
[[prototype]] 与 __proto__
 [[prototype]] 和 __proto__ 意义相同，其值指向对象原型
 [[prototype]] 是内置属性，是一个规范或标准属性，用户不可访问
 __proto__ 不是一个规范或标准属性，但是在部分浏览器实现了此属性
 原型继承（又称为原型链继承）
 构造继承（又称为 call 继承）
 组合继承（原型继承 + 构造继承）
 原型式继承（类似于原型继承）
 寄生式继承（原型式继承进阶）
 寄生组合式继承（寄生式继承 + 构造继承）


